.#  codec_c.gsl
.#
.#  Generates a codec for a protocol specification
.#
.include "library.gsl"
.resolve_includes ()
.for message
.   message.name = "$(message.name:c)"
.   for field where item() = 1
.       for class.header
.           for field as hfield
.               copy hfield before field
.           endfor
.       endfor
.   else
.       for class.header
.           for field as hfield
.               copy hfield to message
.           endfor
.       endfor
.   endfor
.
.echo "Generating ../../pkg/msg/$(name).go ..."
.output "../../pkg/msg/$(name).go"
.max_length = 7 # 7 = number of characters of "Address"
.for field
.    field.name = "$(field.name:c)"
.    field.name = "$(field.Name)"
.    field.name = string.replace(field.name,'_')
.    if type = "number"
.        if size = 1
.            field.gotype = "byte"
.        elsif size = 2
.            field.gotype = "uint16"
.        elsif size = 4
.            field.gotype = "uint32"
.        elsif size = 8
.            field.gotype = "uint64"
.        else
.            echo "E: bad size $(size) for $(name)"
.        endif
.    elsif type = "octets"
.        field.gotype = "[$(size)]byte"
.    elsif type = "strings"
.        field.gotype = "[]string"
.    elsif type = "dictionary"
.        field.gotype = "map[string]string"
.    elsif type = "string"
.        field.gotype = "string"
.    elsif type = "frame"
.        field.gotype = "[]byte"
.    else
.        echo "E: unknown type'$(type)'"
.    endif
.    if max_length < string.length(field.name)
.        max_length = string.length(field.name)
.    endif
.    for class.field as cfield where cfield.name = field.name
.        if cfield.type <> field.type
.            echo "E: field '$(name)' must have same type everywhere"
.        endif
.    else
.        copy field to class
.    endfor
.endfor
package $(class.name)

import (
	zmq "github.com/vaughan0/go-zmq"

	"bytes"
	"encoding/binary"
	"errors"
)

.struct = "$(Name)"
.struct = string.replace(struct,'_')
const (
	$(struct:no)Id uint8 = $(id)
)

// $(string.trim (.?''):left)
type $(struct:no) struct {
	$("Address"%-$(max_length + 1)s)[]byte
.for field
	$(name:no%-$(max_length + 1)s)$(gotype)
.endfor
}
.self = string.substr(name,0,0)

// New creates new $(struct:no) message
func New$(struct:no)() *$(struct:no) {
	$(struct) := &$(struct:no){}
.for field where type = "dictionary"
	$(struct).$(name:no) = make(map[string]string)
.endfor
	return $(struct)
}

// String returns print friendly name
func ($(self) *$(struct:no)) String() string {
	return "$(NAME)"
}

// Marshal serializes the message
func ($(self) *$(struct:no)) Marshal() ([]byte, error) {
	// Calculate size of serialized data
	bufferSize := 2 + 1 // Signature and message ID
.for field
.    if type = "number"

	// $(name:no) is a $(size)-byte integer
	bufferSize += $(size)
.    elsif type = "octets"

	// $(name:no) is a block of $(size) bytes
	bufferSize += $(size)
.    elsif type = "string"

	// $(name:no) is a string with 1-byte length
.        if defined (field.value)
	bufferSize += 1 + len("$(field.value:)")
.        else
	bufferSize++ // Size is one byte
	bufferSize += len($(self).$(name:no))
.        endif
.    elsif type = "strings"

	// $(name:no) is an array of strings
	bufferSize++ // Size is one byte
	// Add up size of list contents
	for _, val := range $(self).$(name:no) {
		bufferSize += 1 + len(val)
	}
.    elsif type = "dictionary"

	// $(name:no) is an array of key=value strings
	bufferSize++ // Size is one byte
	for _, val := range $(self).$(name:no) {
		bufferSize += 1 + len(val)
	}
.    endif
.endfor

	// Now serialize the message
	b := make([]byte, bufferSize)
	b = b[:0]
	buffer := bytes.NewBuffer(b)
	binary.Write(buffer, binary.BigEndian, Signature)
	binary.Write(buffer, binary.BigEndian, $(struct:no)Id)
.for field
.    if type = "number"

	// $(name:no)
.        if defined (field.value)
	binary.Write(buffer, binary.BigEndian, "$(field.value:)")
.        else
	binary.Write(buffer, binary.BigEndian, $(self).$(name:no))
.        endif
.    elsif type = "octets"

	// $(name:no)
	binary.Write(buffer, binary.BigEndian, $(self).$(name:no))
.    elsif type = "string"

	// $(name:no)
.        if defined (field.value)
	putString(buffer, "$(field.value:)")
.        else
	putString(buffer, $(self).$(name:no))
.        endif
.    elsif type = "strings"

	// $(name:no)
	binary.Write(buffer, binary.BigEndian, byte(len($(self).$(name:no))))
	for _, val := range $(self).$(name:no) {
		putString(buffer, val)
	}
.    elsif type = "dictionary"

	// $(name:no)
	binary.Write(buffer, binary.BigEndian, byte(len($(self).$(name:no))))
	for key, val := range $(self).$(name:no) {
		putKeyValString(buffer, key, val)
	}
.    endif
.endfor

	return buffer.Bytes(), nil
}

// Unmarshal unserializes the message
func ($(self) *$(struct:no)) Unmarshal(frames [][]byte) error {
	frame := frames[0]
	frames = frames[1:]

	buffer := bytes.NewBuffer(frame)

	// Check the signature
	var signature uint16
	binary.Read(buffer, binary.BigEndian, &signature)
	if signature != Signature {
		return errors.New("malformed message")
	}

	var id uint8
	binary.Read(buffer, binary.BigEndian, &id)
	if id != $(struct:no)Id {
		return errors.New("malformed message")
	}
.frames = 0
.for field

	// $(name:no)
.    if type = "number"
	binary.Read(buffer, binary.BigEndian, &$(self).$(name:no))
.        if defined (field.value)
	if $(self).$(name:no) != $(field.value:) {
		return errors.New("malformed message")
	}
.        endif
.    elsif type = "octets"
	binary.Read(buffer, binary.BigEndian, &$(self).$(name:no))
.    elsif type = "string"
	$(self).$(name:no) = getString(buffer)
.        if defined (field.value)
	if $(self).$(name:no) != "$(field.value:)" {
		return errors.New("malformed message")
	}
.        endif
.    elsif type = "strings"
.        size = "$(name)Size"
	var $(size:no) byte
	binary.Read(buffer, binary.BigEndian, &$(size:no))
	for ; $(size:no) != 0; $(size:no)-- {
		$(self).$(name:no) = append($(self).$(name:no), getString(buffer))
	}
.    elsif type = "dictionary"
.        size = "$(name)Size"
	var $(size:no) byte
	binary.Read(buffer, binary.BigEndian, &$(size:no))
	for ; $(size:no) != 0; $(size:no)-- {
		key, val := getKeyValString(buffer)
		$(self).$(name:no)[key] = val
	}
.    elsif type = "frame"
	$(self).$(name:no) = frames[$(frames)]
.    frames = frames + 1
.    endif
.endfor

	return nil
}

// Send sends marshaled data through 0mq socket
func ($(self) *$(struct:no)) Send(socket *zmq.Socket) (err error) {
	frame, err := $(self).Marshal()
	if err != nil {
		return err
	}

	// If we're sending to a ROUTER, we send the address first
	if socket.GetType() == zmq.Router {
		err = socket.SendPart($(self).Address, true)
		if err != nil {
			return err
		}
	}

	// Now send the data frame
.if !count (field, type = "frame")
	err = socket.SendPart(frame, false)
.else
	err = socket.SendPart(frame, true)
.endif
	if err != nil {
		return err
	}
.if count (field, type = "frame")
	// Now send any frame fields, in order
.endif
.for field where type = "frame"
.    if last ()
	err = socket.SendPart($(self).$(name:no), false)
.    else
	err = socket.SendPart($(self).$(name:no), true)
.    endif
.endfor

	return err
}

// SetAddress sets the address for this message, address should be set
// whenever talking to a ROUTER
func ($(self) *$(struct:no)) SetAddress(address []byte) {
	$(self).Address = address
}
.for field as f
.    for class.header
.        for field where name = "$(f.name)"

// Set$(f.name:no) sets $(f.name:no)
func ($(self) *$(struct:no)) Set$(f.name:no)($(f.name) $(f.gotype)) {
	$(self).$(f.name:no) = $(f.name)
}
.        endfor
.    endfor
.endfor
.echo "Generating ../../pkg/msg/$(name)_test.go ..."
.output "../../pkg/msg/$(name)_test.go"
package $(class.name)

import (
	zmq "github.com/vaughan0/go-zmq"

	"testing"
)

func Test$(struct:no)(t *testing.T) {
	context, err := zmq.NewContext()
	if err != nil {
		t.Fatal(err)
	}

	// Output
	output, err := context.Socket(zmq.Dealer)
	if err != nil {
		t.Fatal(err)
	}
	err = output.Bind("inproc://selftest")
	if err != nil {
		t.Fatal(err)
	}

	// Input
	input, err := context.Socket(zmq.Router)
	if err != nil {
		t.Fatal(err)
	}
	err = input.Connect("inproc://selftest")
	if err != nil {
		t.Fatal(err)
	}
	// Create a $(Name) message and send it through the wire
	$(struct) := New$(struct:no)()
.   for field where !defined (value)
.       if type = "number"
	$(struct).$(name:no) = 123
.       elsif type = "octets"
.       data = "'z', " * size
	$(struct).$(name:no) = [$(size)]byte{$(data)}
.       elsif type = "string"
	$(struct).$(name:no) = "Life is short but Now lasts for ever"
.       elsif type = "strings"
	$(struct).$(name:no) = []string{"Name: Brutus", "Age: 43"}
.       elsif type = "dictionary"
	$(struct).$(name:no) = map[string]string{"Name": "Brutus", "Age": "43"}
.       elsif type = "frame"
	$(struct).$(name:no) = []byte("Captcha Diem")
.       endif
.   endfor

	err = $(struct).Send(output)
	if err != nil {
		t.Fatal(err)
	}

	transit, err := Recv(input)
	if err != nil {
		t.Fatal(err)
	}

	msg := transit.(*$(struct:no))
.   for field where !defined (value)
.       if type = "number"
	if msg.$(name:no) != 123 {
		t.Fatalf("expected %d, got %d", 123, msg.$(name:no))
	}
.       elsif type = "octets"
.       data = "'z', " * size
	if len(msg.$(name:no)) != $(size) {
		t.Fatalf("mismatch octets size for %s", "$(name:no)")
	}
	for idx, b := range [$(size)]byte{$(data)} {
		if msg.$(name:no)[idx] != b {
			t.Fatalf("mismatch octets value for %s", "$(name:no)")
		}
	}
.       elsif type = "string"
	if msg.$(name:no) != "Life is short but Now lasts for ever" {
		t.Fatalf("expected %s, got %s", "Life is short but Now lasts for ever", msg.$(name:no))
	}
.       elsif type = "strings"
	for idx, str := range []string{"Name: Brutus", "Age: 43"} {
		if msg.$(name:no)[idx] != str {
			t.Fatalf("expected %s, got %s", str, msg.$(name:no)[idx])
		}
	}
.       elsif type = "dictionary"
	for key, val := range map[string]string{"Name": "Brutus", "Age": "43"} {
		if msg.$(name:no)[key] != val {
			t.Fatalf("expected %s, got %s", val, msg.$(name:no)[key])
		}
	}
.       elsif type = "frame"
	if string(msg.$(name:no)) != "Captcha Diem" {
		t.Fatalf("expected %s, got %s", "Captcha Diem", msg.$(name:no))
	}
.       endif
.   endfor
}
.endfor
.echo "Generating ../../pkg/msg/$(name).go ..."
.output "../../pkg/msg/$(name).go"
package $(class.name)

import (
	zmq "github.com/vaughan0/go-zmq"

	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"strings"
)

.max_length = 16 # 16 is number of characters of Signature and its type
.for define
.    if max_length < string.length($(define.Name:c))
.        max_length = string.length($(define.Name:c))
.    endif
.endfor
const (
	Signature uint16 = 0xAAA0 | $(class.signature)
	$("StringMax"%-$(max_length)s) = 255
.for define
	$(define.Name:c%-$(max_length)s) = $(value)
.endfor
)

type Transit interface {
	Marshal() ([]byte, error)
	Unmarshal([][]byte) error
	String() string
	SetAddress([]byte)
	Send(*zmq.Socket) error
.for field as f
.    for class.header
.        for field where name = "$(f.name)"
	Set$(f.name:no)($(f.gotype))
.        endfor
.    endfor
.endfor
}

// Recv receives marshaled data from 0mq socket
func Recv(socket *zmq.Socket) (t Transit, err error) {
	var (
		buffer  *bytes.Buffer
		address []byte
		frames  [][]byte
	)

	// Read valid message frame from socket; we loop over any
	// garbage data we might receive from badly-connected peers
	for {
		// Read all frames
		frames, err = socket.Recv()
		if err != nil {
			return nil, err
		}
		// If we're reading from a ROUTER socket, get address
		if socket.GetType() == zmq.Router {
			if len(frames) <= 1 {
				return nil, errors.New("malformed message")
			}
			address = frames[0]
			frames = frames[1:]
		}
		// Check the signature
		var signature uint16
		buffer = bytes.NewBuffer(frames[0])
		binary.Read(buffer, binary.BigEndian, &signature)
		if signature == Signature {
			// Valid signature
			break
		}
	}

	// Get message id and parse per message type
	var id uint8
	binary.Read(buffer, binary.BigEndian, &id)

	switch id {
.for message
.   message.name = "$(message.name:c)"
.   name = "$(Name)"
.   name = string.replace(name,'_')
	case $(name:no)Id:
		t = New$(name:no)()
.endfor
	}
	t.SetAddress(address)
	err = t.Unmarshal(frames)

	return t, err
}

// putString marshals a string into the buffer
func putString(buffer *bytes.Buffer, str string) {
	size := len(str)
	if size > StringMax {
		size = StringMax
	}
	sz := fmt.Sprintf("%d", size)
	str = fmt.Sprintf("%"+sz+"s", str)
	binary.Write(buffer, binary.BigEndian, byte(size))
	binary.Write(buffer, binary.BigEndian, []byte(str))
}

// putKeyValString marshals a key=val pair into the buffer
func putKeyValString(buffer *bytes.Buffer, key, val string) {
	str := fmt.Sprintf("%s=%s", key, val)
	putString(buffer, str)
}

// getString unmarshals a string from the buffer
func getString(buffer *bytes.Buffer) string {
	var size byte
	binary.Read(buffer, binary.BigEndian, &size)
	str := make([]byte, size)
	binary.Read(buffer, binary.BigEndian, &str)
	return string(str)
}

// getKeyValString unmarshals a key=val pair from the buffer
func getKeyValString(buffer *bytes.Buffer) (key, val string) {
	str := getString(buffer)
	strs := strings.SplitN(str, "=", 2)

	if len(strs) == 2 {
		return strs[0], strs[1]
	}

	return "", ""
}
