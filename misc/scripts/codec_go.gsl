.#  codec_c.gsl
.#
.#  Generates a codec for a protocol specification
.#
.include "library.gsl"
.resolve_includes ()
.for message
.   message.name = "$(message.name:c)"
.   for field where item() = 1
.       for class.header
.           for field as hfield
.               hfield.header = "true"
.               copy hfield before field
.           endfor
.       endfor
.   else
.       for class.header
.           for field as hfield
.               hfield.header = "true"
.               copy hfield to message
.           endfor
.       endfor
.   endfor
.
.echo "Generating $(name).go ..."
.output "$(path)/$(name).go"
.# 7 = number of characters of "Address"
.max_length = defined(socket) ?? 7 ? 0
.for field
.    field.name = "$(field.name:c)"
.    field.name = "$(field.Name)"
.    field.name = string.replace(field.name,'_')
.    if type = "number"
.        if size = 1
.            field.gotype = "byte"
.        elsif size = 2
.            field.gotype = "uint16"
.        elsif size = 4
.            field.gotype = "uint32"
.        elsif size = 8
.            field.gotype = "uint64"
.        else
.            echo "E: bad size $(size) for $(name)"
.        endif
.    elsif type = "octets"
.        if defined(size)
.            field.gotype = "[$(size)]byte"
.        else
.            field.gotype = "[]byte"
.        endif
.    elsif type = "strings"
.        field.gotype = "[]string"
.    elsif type = "dictionary"
.        field.gotype = "map[string]string"
.    elsif type = "string"
.        field.gotype = "string"
.    elsif type = "frame"
.        field.gotype = "[]byte"
.    else
.        echo "E: unknown type'$(type)'"
.    endif
.    if max_length < string.length(field.name)
.        max_length = string.length(field.name)
.    endif
.    for class.field as cfield where cfield.name = field.name
.        if cfield.type <> field.type
.            echo "E: field '$(name)' must have same type everywhere"
.        endif
.    else
.        copy field to class
.    endfor
.endfor
package $(class.name)

import (
.if defined(socket)
	zmq "github.com/armen/go-zmq"

.endif
	"bytes"
	"encoding/binary"
	"errors"
)

.struct = "$(Name)"
.struct = string.replace(struct,'_')
// $(string.trim (.?''):left)
type $(struct:no) struct {
.if defined(socket)
	$("address"%-$(max_length + 1)s)[]byte
.endif
.for field
.    fname = defined(header) ?? "$(name)" ? "$(name:no)"
	$(fname:no%-$(max_length + 1)s)$(gotype)
.endfor
}
.self = string.substr(name,0,0)

// New creates new $(struct:no) message
func New$(struct:no)() *$(struct:no) {
	$(struct) := &$(struct:no){}
.for field where type = "dictionary"
	$(struct).$(name:no) = make(map[string]string)
.endfor
	return $(struct)
}

// String returns print friendly name
func ($(self) *$(struct:no)) String() string {
	return "$(NAME)"
}

// Marshal serializes the message
func ($(self) *$(struct:no)) Marshal() ([]byte, error) {
	// Calculate size of serialized data
	bufferSize := 2 + 1 // Signature and message ID
.for field
.    fname = defined(header) ?? "$(name:no)()" ? "$(name:no)"
.    if type = "number"

	// $(name:no) is a $(size)-byte integer
	bufferSize += $(size)
.    elsif type = "octets"

.        if defined(size)
	// $(name:no) is a block of [$(size)]byte
	bufferSize += $(size)
.        else
	// $(name:no) is a block of []byte with one byte length
	bufferSize += 1 + len($(self).$(fname:no))
.        endif
.    elsif type = "string"

	// $(name:no) is a string with 1-byte length
.        if defined (field.value)
	bufferSize += 1 + len("$(field.value:)")
.        else
	bufferSize++ // Size is one byte
	bufferSize += len($(self).$(fname:no))
.        endif
.    elsif type = "strings"

	// $(name:no) is an array of strings
	bufferSize++ // Size is one byte
	// Add up size of list contents
	for _, val := range $(self).$(fname:no) {
		bufferSize += 1 + len(val)
	}
.    elsif type = "dictionary"

	// $(name:no) is an array of key=value strings
	bufferSize++ // Size is one byte
	for _, val := range $(self).$(fname:no) {
		bufferSize += 1 + len(val)
	}
.    endif
.endfor

	// Now serialize the message
	b := make([]byte, bufferSize)
	b = b[:0]
	buffer := bytes.NewBuffer(b)
	binary.Write(buffer, binary.BigEndian, Signature)
	binary.Write(buffer, binary.BigEndian, $(struct:no)Id)
.for field
.    fname = defined(header) ?? "$(name:no)()" ? "$(name:no)"
.    if type = "number"

	// $(name:no)
.        if defined (field.value)
	binary.Write(buffer, binary.BigEndian, "$(field.value:)")
.        else
	binary.Write(buffer, binary.BigEndian, $(self).$(fname:no))
.        endif
.    elsif type = "octets"

	// $(name:no)
.        if defined(size)
	binary.Write(buffer, binary.BigEndian, $(self).$(fname:no))
.        else
	putBytes(buffer, $(self).$(fname:no))
.        endif
.    elsif type = "string"

	// $(name:no)
.        if defined (field.value)
	putString(buffer, "$(field.value:)")
.        else
	putString(buffer, $(self).$(fname:no))
.        endif
.    elsif type = "strings"

	// $(name:no)
	binary.Write(buffer, binary.BigEndian, byte(len($(self).$(fname:no))))
	for _, val := range $(self).$(fname:no) {
		putString(buffer, val)
	}
.    elsif type = "dictionary"

	// $(name:no)
	binary.Write(buffer, binary.BigEndian, byte(len($(self).$(fname:no))))
	for key, val := range $(self).$(fname:no) {
		putKeyValString(buffer, key, val)
	}
.    endif
.endfor

	return buffer.Bytes(), nil
}

// Unmarshal unserializes the message
func ($(self) *$(struct:no)) Unmarshal(frames ...[]byte) error {
	frame := frames[0]
	frames = frames[1:]

	buffer := bytes.NewBuffer(frame)

	// Check the signature
	var signature uint16
	binary.Read(buffer, binary.BigEndian, &signature)
	if signature != Signature {
		return errors.New("malformed message")
	}

	var id uint8
	binary.Read(buffer, binary.BigEndian, &id)
	if id != $(struct:no)Id {
		return errors.New("malformed message")
	}
.frames = 0
.for field
.    fname = defined(header) ?? "$(name)" ? "$(name:no)"

	// $(name:no)
.    if type = "number"
	binary.Read(buffer, binary.BigEndian, &$(self).$(fname:no))
.        if defined (field.value)
	if $(self).$(fname:no) != $(field.value:) {
		return errors.New("malformed message")
	}
.        endif
.    elsif type = "octets"
.        if defined(size)
	binary.Read(buffer, binary.BigEndian, &$(self).$(fname:no))
.        else
	$(self).$(fname:no) = getBytes(buffer)
.        endif
.    elsif type = "string"
	$(self).$(fname:no) = getString(buffer)
.        if defined (field.value)
	if $(self).$(fname:no) != "$(field.value:)" {
		return errors.New("malformed message")
	}
.        endif
.    elsif type = "strings"
.        _size = "$(fname)Size"
	var $(_size:no) byte
	binary.Read(buffer, binary.BigEndian, &$(_size:no))
	for ; $(_size:no) != 0; $(_size:no)-- {
		$(self).$(fname:no) = append($(self).$(fname:no), getString(buffer))
	}
.    elsif type = "dictionary"
.        _size = "$(fname)Size"
	var $(_size:no) byte
	binary.Read(buffer, binary.BigEndian, &$(_size:no))
	for ; $(_size:no) != 0; $(_size:no)-- {
		key, val := getKeyValString(buffer)
		$(self).$(fname:no)[key] = val
	}
.    elsif type = "frame"
	if $(frames) <= len(frames)-1 {
		$(self).$(fname:no) = frames[$(frames)]
	}
.    frames = frames + 1
.    endif
.endfor

	return nil
}
.if defined(socket)

// Send sends marshaled data through 0mq socket
func ($(self) *$(struct:no)) Send(socket *zmq.Socket) (err error) {
	frame, err := $(self).Marshal()
	if err != nil {
		return err
	}

	// If we're sending to a ROUTER, we send the address first
	if socket.GetType() == zmq.Router {
		err = socket.SendPart($(self).address, true)
		if err != nil {
			return err
		}
	}

	// Now send the data frame
.if !count (field, type = "frame")
	err = socket.SendPart(frame, false)
.else
	err = socket.SendPart(frame, true)
.endif
	if err != nil {
		return err
	}
.if count (field, type = "frame")
	// Now send any frame fields, in order
.endif
.for field where type = "frame"
.    fname = defined(header) ?? "$(name)" ? "$(name:no)"
.    if last ()
	err = socket.SendPart($(self).$(fname:no), false)
.    else
	err = socket.SendPart($(self).$(fname:no), true)
.    endif
.endfor

	return err
}

// Address returns the address for this message, address should is set
// whenever talking to a ROUTER
func ($(self) *$(struct:no)) Address() []byte {
	return $(self).address
}

// SetAddress sets the address for this message, address should be set
// whenever talking to a ROUTER
func ($(self) *$(struct:no)) SetAddress(address []byte) {
	$(self).address = address
}
.endif
.for field where defined(header)

// Set$(name:no) sets the $(name)
func ($(self) *$(struct:no)) Set$(name:no)($(name) $(gotype)) {
	$(self).$(name) = $(name)
}

// $(name:no) returns the $(name)
func ($(self) *$(struct:no)) $(name:no)() $(gotype) {
	return $(self).$(name)
}
.endfor
.echo "Generating $(name)_test.go ..."
.output "$(path)/$(name)_test.go"
package $(class.name)

import (
.if defined(socket)
	zmq "github.com/armen/go-zmq"

.endif
	"testing"
)

func Test$(struct:no)(t *testing.T) {
.if defined(socket)
	context, err := zmq.NewContext()
	if err != nil {
		t.Fatal(err)
	}

	// Output
	output, err := context.Socket(zmq.Dealer)
	if err != nil {
		t.Fatal(err)
	}
	address := []byte("Shout")
	output.SetIdentitiy(address)
	err = output.Bind("inproc://selftest")
	if err != nil {
		t.Fatal(err)
	}

	// Input
	input, err := context.Socket(zmq.Router)
	if err != nil {
		t.Fatal(err)
	}
	err = input.Connect("inproc://selftest")
	if err != nil {
		t.Fatal(err)
	}
.endif
	// Create a $(Name) message and send it through the wire
	$(struct) := New$(struct:no)()
.   for field where !defined (value)
.       if defined(header)
.           if type = "number"
	$(struct).Set$(name:no)(123)
.           elsif type = "octets"
.               if defined(size)
.                   data = "'z', " * size
	$(struct).Set$(name:no)([$(size)]byte{$(data)})
.               else
	$(struct).Set$(name:no)([]byte{'z', 'y'})
.               endif
.           elsif type = "string"
	$(struct).Set$(name:no)("Life is short but Now lasts for ever")
.           elsif type = "strings"
	$(struct).Set$(name:no)([]string{"Name: Brutus", "Age: 43"})
.           elsif type = "dictionary"
	$(struct).Set$(name:no)(map[string]string{"Name": "Brutus", "Age": "43"})
.           elsif type = "frame"
	$(struct).Set$(name:no)([]byte("Captcha Diem"))
.           endif
.       else
.           if type = "number"
	$(struct).$(name:no) = 123
.           elsif type = "octets"
.               if defined(size)
.                   data = "'z', " * size
	$(struct).$(name:no) = [$(size)]byte{$(data)}
.               else
	$(struct).$(name:no) = []byte{'z', 'y'}
.               endif
.           elsif type = "string"
	$(struct).$(name:no) = "Life is short but Now lasts for ever"
.           elsif type = "strings"
	$(struct).$(name:no) = []string{"Name: Brutus", "Age: 43"}
.           elsif type = "dictionary"
	$(struct).$(name:no) = map[string]string{"Name": "Brutus", "Age": "43"}
.           elsif type = "frame"
	$(struct).$(name:no) = []byte("Captcha Diem")
.           endif
.       endif
.   endfor

.if defined(socket)
	err = $(struct).Send(output)
	if err != nil {
		t.Fatal(err)
	}
	transit, err := Recv(input)
	if err != nil {
		t.Fatal(err)
	}
.else
	marshaled, err := $(struct).Marshal()
	if err != nil {
		t.Fatal(err)
	}
	transit, err := Unmarshal(marshaled)
	if err != nil {
		t.Fatal(err)
	}
.endif

	tr := transit.(*$(struct:no))
.   for field where !defined (value)
.       fname = defined(header) ?? "$(name:no)()" ? "$(name:no)"
.       if type = "number"
	if tr.$(fname:no) != 123 {
		t.Fatalf("expected %d, got %d", 123, tr.$(fname:no))
	}
.       elsif type = "octets"
.           if defined(size)
.           data = "'z', " * size
	if len(tr.$(fname:no)) != $(size) {
		t.Fatalf("mismatch octets size for %s", "$(fname:no)")
	}
	for idx, b := range [$(size)]byte{$(data)} {
		if tr.$(fname:no)[idx] != b {
			t.Fatalf("mismatch octets value for %s", "$(fname:no)")
		}
	}
.           else
	if len(tr.$(fname:no)) != 2 {
		t.Fatalf("mismatch octets size for %s", "$(fname:no)")
	}
	for idx, b := range []byte{'z', 'y'} {
		if tr.$(fname:no)[idx] != b {
			t.Fatalf("mismatch octets value for %s", "$(fname:no)")
		}
	}
.           endif
.       elsif type = "string"
	if tr.$(fname:no) != "Life is short but Now lasts for ever" {
		t.Fatalf("expected %s, got %s", "Life is short but Now lasts for ever", tr.$(fname:no))
	}
.       elsif type = "strings"
	for idx, str := range []string{"Name: Brutus", "Age: 43"} {
		if tr.$(fname:no)[idx] != str {
			t.Fatalf("expected %s, got %s", str, tr.$(fname:no)[idx])
		}
	}
.       elsif type = "dictionary"
	for key, val := range map[string]string{"Name": "Brutus", "Age": "43"} {
		if tr.$(fname:no)[key] != val {
			t.Fatalf("expected %s, got %s", val, tr.$(fname:no)[key])
		}
	}
.       elsif type = "frame"
.           if defined(socket)
	if string(tr.$(fname:no)) != "Captcha Diem" {
		t.Fatalf("expected %s, got %s", "Captcha Diem", tr.$(fname:no))
	}
.           endif
.       endif
.   endfor

.if defined(socket)
	err = tr.Send(input)
	if err != nil {
		t.Fatal(err)
	}
	transit, err = Recv(output)
	if err != nil {
		t.Fatal(err)
	}
	if string(address) != string(tr.Address()) {
		t.Fatalf("expected %v, got %v", address, tr.Address())
	}
.else
	marshaled, err = $(struct).Marshal()
	if err != nil {
		t.Fatal(err)
	}
	transit, err = Unmarshal(marshaled)
	if err != nil {
		t.Fatal(err)
	}
.endif
}
.endfor
.echo "Generating $(name).go ..."
.output "$(path)/$(name).go"
package $(class.name)

import (
.if defined(socket)
	zmq "github.com/armen/go-zmq"

.endif
	"bytes"
	"encoding/binary"
	"errors"
	"fmt"
	"strings"
)

.max_length = 16 # 16 is number of characters of Signature and its type
.for define
.    if max_length < string.length($(define.Name:c))
.        max_length = string.length($(define.Name:c))
.    endif
.endfor
const (
	Signature uint16 = 0xAAA0 | $(class.signature)
	$("StringMax"%-$(max_length)s) = 255
.for define
	$(define.Name:c%-$(max_length)s) = $(value)
.endfor
)

.max_name = 0
.for message
.   message.name = "$(message.name:c)"
.   name = "$(Name)"
.   name = string.replace(name,'_')
.    if max_name < string.length(name)+2
.        max_name = string.length(name)+2
.    endif
.endfor
const (
.for message
	$("$(name:no)Id"%-$(max_name)s) uint8 = $(id)
.endfor
)

type Transit interface {
	Marshal() ([]byte, error)
	Unmarshal(...[]byte) error
	String() string
.if defined(socket)
	Send(*zmq.Socket) error
	SetAddress([]byte)
	Address() []byte
.endif
.for field where defined(header)
	Set$(name:no)($(gotype))
	$(name:no)() $(gotype)
.endfor
}
.if defined(socket)

// Recv receives marshaled data from 0mq socket
func Recv(socket *zmq.Socket) (t Transit, err error) {
	// Read valid message frame from socket; we loop over any
	// garbage data we might receive from badly-connected peers
	for {
		// Read all frames
		frames, err := socket.Recv()
		if err != nil {
			return nil, err
		}
		t, err := Unmarshal(socket.GetType(), frames...)
		if err != nil {
			continue
		}
		return t, err
	}
}
.endif

// Unmarshals data from raw frames
.if defined(socket)
func Unmarshal(sType zmq.SocketType, frames ...[]byte) (t Transit, err error) {
.else
func Unmarshal(frames ...[]byte) (t Transit, err error) {
.endif
.if defined(socket)
	var (
		buffer  *bytes.Buffer
		address []byte
	)
.else
	var buffer *bytes.Buffer
.endif
.if defined(socket)

	// If we're reading from a ROUTER socket, get address
	if sType == zmq.Router {
		if len(frames) <= 1 {
			return nil, errors.New("malformed message")
		}
		address = frames[0]
		frames = frames[1:]
	}
.endif

	// Check the signature
	var signature uint16
	buffer = bytes.NewBuffer(frames[0])
	binary.Read(buffer, binary.BigEndian, &signature)
	if signature != Signature {
		// Invalid signature
		return nil, errors.New("malformed message")
	}

	// Get message id and parse per message type
	var id uint8
	binary.Read(buffer, binary.BigEndian, &id)

	switch id {
.for message
	case $(name:no)Id:
		t = New$(name:no)()
.endfor
	}
.if defined(socket)
	t.SetAddress(address)
.endif
	err = t.Unmarshal(frames...)

	return t, err
}

// Clone clones a message
func Clone(t Transit) Transit {
	switch msg := t.(type) {
.for message
	case *$(name:no):
		cloned := New$(name:no)()
.    for field
.       fname = defined(header) ?? "$(name)" ? "$(name:no)"
.       if type = "dictionary"
		for key, val := range msg.$(fname:no) {
			cloned.$(fname:no)[key] = val
		}
.       elsif type = "strings"
		for idx, str := range msg.$(fname:no) {
			cloned.$(fname:no)[idx] = str
		}
.       elsif type = "octets" | type = "frame"
		cloned.$(fname:no) = append(cloned.$(fname:no), msg.$(fname:no)...)
.       else
		cloned.$(fname:no) = msg.$(fname:no)
.       endif
.    endfor
		return cloned
.    if last ()
.    else

.endif
.endfor
	}

	return nil
}

// putString marshals a string into the buffer
func putString(buffer *bytes.Buffer, str string) {
	size := len(str)
	if size > StringMax {
		size = StringMax
	}
	sz := fmt.Sprintf("%d", size)
	str = fmt.Sprintf("%"+sz+"s", str)
	binary.Write(buffer, binary.BigEndian, byte(size))
	binary.Write(buffer, binary.BigEndian, []byte(str))
}

// putKeyValString marshals a key=val pair into the buffer
func putKeyValString(buffer *bytes.Buffer, key, val string) {
	str := fmt.Sprintf("%s=%s", key, val)
	putString(buffer, str)
}

// getString unmarshals a string from the buffer
func getString(buffer *bytes.Buffer) string {
	var size byte
	binary.Read(buffer, binary.BigEndian, &size)
	str := make([]byte, size)
	binary.Read(buffer, binary.BigEndian, &str)
	return string(str)
}

// getKeyValString unmarshals a key=val pair from the buffer
func getKeyValString(buffer *bytes.Buffer) (key, val string) {
	str := getString(buffer)
	strs := strings.SplitN(str, "=", 2)

	if len(strs) == 2 {
		return strs[0], strs[1]
	}

	return "", ""
}

// putBytes marshals []byte into the buffer
func putBytes(buffer *bytes.Buffer, data []byte) {
	size := uint64(len(data))
	binary.Write(buffer, binary.BigEndian, size)
	binary.Write(buffer, binary.BigEndian, data)
}

// getBytes unmarshals []byte from the buffer
func getBytes(buffer *bytes.Buffer) []byte {
	var size uint64
	binary.Read(buffer, binary.BigEndian, &size)
	data := make([]byte, size)
	binary.Read(buffer, binary.BigEndian, &data)
	return data
}
